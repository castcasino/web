/**
 * pokersolver v2.1.2
 * Copyright (c) 2016, James Simpson of GoldFire Studios
 * http://goldfirestudios.com
 */

// (function() {
//   'use strict';

// NOTE: The 'joker' will be denoted with a value of 'O' and any suit.
import values from './solver/values.js'

import Card from './solver/Card.js'

  /**
   * Base Hand class that handles comparisons of full hands.
   */
  class Hand {
    constructor(cards, name, game, canDisqualify) {
      this.cardPool = [];
      this.cards = [];
      this.suits = {};
      this.values = [];
      this.wilds = [];
      this.name = name;
      this.game = game;
      this.sfLength = 0;
      this.alwaysQualifies = true;

      // Qualification rules apply for dealer's hand.
      // Also applies for single player games, like video poker.
      if (canDisqualify && this.game.lowestQualified) {
        this.alwaysQualifies = false;
      }

      // Ensure no duplicate cards in standard game.
      if (game.descr === 'standard' && new Set(cards).size !== cards.length) {
        throw new Error('Duplicate cards');
      }

      // Get rank based on game.
      var handRank = this.game.handValues.length;
      for (var i=0; i<this.game.handValues.length; i++) {
        if (this.game.handValues[i] === this.constructor) {
          break;
        }
      }
      this.rank = handRank - i;

      // Set up the pool of cards.
      this.cardPool = cards.map(function(c) {
        return (typeof c === 'string') ? new Card(c) : c;
      });

      // Fix the card ranks for wild cards, and sort.
      for (var i=0; i<this.cardPool.length; i++) {
        card = this.cardPool[i];
        if (card.value === this.game.wildValue) {
          card.rank = -1;
        }
      }
      this.cardPool = this.cardPool.sort(Card.sort);

      // Create the arrays of suits and values.
      var obj, obj1, key, key1, card;
      for (var i=0; i<this.cardPool.length; i++) {
        // Make sure this value already exists in the object.
        card = this.cardPool[i];

        // We do something special if this is a wild card.
        if (card.rank === -1) {
          this.wilds.push(card);
        } else {
          (obj = this.suits)[key = card.suit] || (obj[key] = []);
          (obj1 = this.values)[key1 = card.rank] || (obj1[key1] = []);

          // Add the value to the array for that type in the object.
          this.suits[card.suit].push(card);
          this.values[card.rank].push(card);
        }
      }

      this.values.reverse();
      this.isPossible = this.solve();
    }

    /**
     * Compare current hand with another to determine which is the winner.
     * @param  {Hand} a Hand to compare to.
     * @return {Number}
     */
    compare(a) {
      if (this.rank < a.rank) {
        return 1;
      } else if (this.rank > a.rank) {
        return -1;
      }

      var result = 0;
      for (var i=0; i<=4; i++) {
        if (this.cards[i] && a.cards[i] && this.cards[i].rank < a.cards[i].rank) {
          result = 1;
          break;
        } else if (this.cards[i] && a.cards[i] && this.cards[i].rank > a.cards[i].rank) {
          result = -1;
          break;
        }
      }

      return result;
    }

    /**
     * Determine whether a hand loses to another.
     * @param  {Hand} hand Hand to compare to.
     * @return {Boolean}
     */
    loseTo(hand) {
      return (this.compare(hand) > 0);
    }

    /**
     * Determine the number of cards in a hand of a rank.
     * @param  {Number} val Index of this.values.
     * @return {Number} Number of cards having the rank, including wild cards.
     */
    getNumCardsByRank(val) {
      var cards = this.values[val];
      var checkCardsLength = (cards) ? cards.length : 0;

      for (var i=0; i<this.wilds.length; i++) {
        if (this.wilds[i].rank > -1) {
          continue;
        } else if (cards) {
          if (this.game.wildStatus === 1 || cards[0].rank === values.length - 1) {
            checkCardsLength += 1;
          }
        } else if (this.game.wildStatus === 1 || val === values.length - 1) {
          checkCardsLength += 1;
        }
      }

      return checkCardsLength;
    }

    /**
     * Determine the cards in a suit for a flush.
     * @param  {String} suit Key for this.suits.
     * @param  {Boolean} setRanks Whether to set the ranks for the wild cards.
     * @return {Array} Cards having the suit, including wild cards.
     */
    getCardsForFlush(suit, setRanks) {
      var cards = (this.suits[suit] || []).sort(Card.sort);

      for (var i=0; i<this.wilds.length; i++) {
        var wild = this.wilds[i];

        if (setRanks) {
          var j=0;
          while (j<values.length && j<cards.length) {
            if (cards[j].rank === values.length-1-j) {
              j += 1;
            } else {
              break;
            }
          }
          wild.rank = values.length-1-j;
          wild.wildValue = values[wild.rank];
        }

        cards.push(wild);
        cards = cards.sort(Card.sort);
      }

      return cards;
    }

    /**
     * Resets the rank and wild values of the wild cards.
     */
    resetWildCards() {
      for (var i=0; i<this.wilds.length; i++) {
        this.wilds[i].rank = -1;
        this.wilds[i].wildValue = this.wilds[i].value;
      }
    }

    /**
     * Highest card comparison.
     * @return {Array} Highest cards
     */
    nextHighest() {
      var picks;
      var excluding = [];
      excluding = excluding.concat(this.cards);

      picks = this.cardPool.filter(function(card) {
        if (excluding.indexOf(card) < 0) {
          return true;
        }
      });

      // Account for remaining wild card when it must be ace.
      if (this.game.wildStatus === 0) {
        for (var i=0; i<picks.length; i++) {
          var card = picks[i];
          if (card.rank === -1) {
            card.wildValue = 'A';
            card.rank = values.length - 1;
          }
        }
        picks = picks.sort(Card.sort);
      }

      return picks;
    }

    /**
     * Return list of contained cards in human readable format.
     * @return {String}
     */
    toString() {
      var cards = this.cards.map(function(c) {
        return c.toString();
      });

      return cards.join(', ');
    }

    /**
     * Return array of contained cards.
     * @return {Array}
     */
    toArray() {
      var cards = this.cards.map(function(c) {
        return c.toString();
      });

      return cards;
    }

    /**
     * Determine if qualifying hand.
     * @return {Boolean}
     */
    qualifiesHigh() {
      if (!this.game.lowestQualified || this.alwaysQualifies) {
        return true;
      }

      return (this.compare(Hand.solve(this.game.lowestQualified, this.game)) <= 0);
    }

    /**
     * Find highest ranked hands and remove any that don't qualify or lose to another hand.
     * @param  {Array} hands Hands to evaluate.
     * @return {Array}       Winning hands.
     */
    static winners(hands) {
      hands = hands.filter(function(h) {
        return h.qualifiesHigh();
      });

      var highestRank = Math.max.apply(Math, hands.map(function(h) {
        return h.rank;
      }));

      hands = hands.filter(function(h) {
        return h.rank === highestRank;
      });

      hands = hands.filter(function(h) {
        var lose = false;
        for (var i=0; i<hands.length; i++) {
          lose = h.loseTo(hands[i]);
          if (lose) {
            break;
          }
        }

        return !lose;
      });

      return hands;
    }

    /**
     * Build and return the best hand.
     * @param  {Array} cards Array of cards (['Ad', '3c', 'Th', ...]).
     * @param  {String} game Game being played.
     * @param  {Boolean} canDisqualify Check for a qualified hand.
     * @return {Hand}       Best hand.
     */
    static solve(cards, game, canDisqualify) {
      game = game || 'standard';
      game = (typeof game === 'string') ? new Game(game) : game;
      cards = cards || [''];

      var hands = game.handValues;
      var result = null;

      for (var i=0; i<hands.length; i++) {
        result = new hands[i](cards, game, canDisqualify);
        if (result.isPossible) {
          break;
        }
      }

      return result;
    }

    /**
     * Separate cards based on if they are wild cards.
     * @param  {Array} cards Array of cards (['Ad', '3c', 'Th', ...]).
     * @param  {Game} game Game being played.
     * @return {Array} [wilds, nonWilds] Wild and non-Wild Cards.
     */
    static stripWilds(cards, game) {
      var card, wilds, nonWilds;
      cards = cards || [''];
      wilds = [];
      nonWilds = [];

      for (var i=0; i<cards.length; i++) {
        card = cards[i];
        if (card.rank === -1) {
          wilds.push(cards[i]);
        } else {
          nonWilds.push(cards[i]);
        }
      }

      return [wilds, nonWilds];
    }
  }

import StraightFlush from './solver/StraightFlush.js'
import RoyalFlush from './solver/RoyalFlush.js'
import NaturalRoyalFlush from './solver/NaturalRoyalFlush.js'
import WildRoyalFlush from './solver/WildRoyalFlush.js'
import FiveOfAKind from './solver/FiveOfAKind.js'
import FourOfAKindPairPlus from './solver/FourOfAKindPairPlus.js'
import FourOfAKind from './solver/FourOfAKind.js'
import FourWilds from './solver/FourWilds.js'
import ThreeOfAKindTwoPair from './solver/ThreeOfAKindTwoPair.js'
import FullHouse from './solver/FullHouse.js'
import Flush from './solver/Flush.js'
import Straight from './solver/Straight.js'
import TwoThreeOfAKind from './solver/TwoThreeOfAKind.js'
import ThreeOfAKind from './solver/ThreeOfAKind.js'
import ThreePair from './solver/ThreePair.js'
import TwoPair from './solver/TwoPair.js'
import OnePair from './solver/OnePair.js'
import HighCard from './solver/HighCard.js'
import PaiGowPokerHelper from './solver/PaiGowPokerHelper.js'

const gameRules = {
    'standard': {
      'cardsInHand': 5,
      'handValues': [
          StraightFlush,
          FourOfAKind,
          FullHouse,
          Flush,
          Straight,
          ThreeOfAKind,
          TwoPair,
          OnePair,
          HighCard,
      ],
      'wildValue': null,
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 5,
      'lowestQualified': null,
      "noKickers": false
    },
    'jacksbetter': {
      'cardsInHand': 5,
      'handValues': [StraightFlush, FourOfAKind, FullHouse, Flush, Straight, ThreeOfAKind, TwoPair, OnePair, HighCard],
      'wildValue': null,
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 5,
      'lowestQualified': ['Jc', 'Jd', '4h', '3s', '2c'],
      "noKickers": true
    },
    'joker': {
      'cardsInHand': 5,
      'handValues': [NaturalRoyalFlush, FiveOfAKind, WildRoyalFlush, StraightFlush, FourOfAKind, FullHouse, Flush, Straight, ThreeOfAKind, TwoPair, HighCard],
      'wildValue': 'O',
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 5,
      'lowestQualified': ['4c', '3d', '3h', '2s', '2c'],
      "noKickers": true
    },
    'deuceswild': {
      'cardsInHand': 5,
      'handValues': [NaturalRoyalFlush, FourWilds, WildRoyalFlush, FiveOfAKind, StraightFlush, FourOfAKind, FullHouse, Flush, Straight, ThreeOfAKind, HighCard],
      'wildValue': '2',
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 5,
      'lowestQualified': ['5c', '4d', '3h', '3s', '3c'],
      "noKickers": true
    },
    'threecard': {
      'cardsInHand': 3,
      'handValues': [StraightFlush, ThreeOfAKind, Straight, Flush, OnePair, HighCard],
      'wildValue': null,
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 3,
      'lowestQualified': ['Qh', '3s', '2c'],
      "noKickers": false
    },
    'fourcard': {
      'cardsInHand': 4,
      'handValues': [FourOfAKind, StraightFlush, ThreeOfAKind, Flush, Straight, TwoPair, OnePair, HighCard],
      'wildValue': null,
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 4,
      'lowestQualified': null,
      "noKickers": true
    },
    'fourcardbonus': {
      'cardsInHand': 4,
      'handValues': [FourOfAKind, StraightFlush, ThreeOfAKind, Flush, Straight, TwoPair, OnePair, HighCard],
      'wildValue': null,
      'wildStatus': 1,
      'wheelStatus': 0,
      'sfQualify': 4,
      'lowestQualified': ['Ac', 'Ad', '3h', '2s'],
      "noKickers": true
    },
    'paigowpokerfull': {
      'cardsInHand': 7,
      'handValues': [FiveOfAKind, FourOfAKindPairPlus, StraightFlush, Flush, Straight, FourOfAKind, TwoThreeOfAKind, ThreeOfAKindTwoPair, FullHouse, ThreeOfAKind, ThreePair, TwoPair, OnePair, HighCard],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 5,
      'lowestQualified': null
    },
    'paigowpokeralt': {
      'cardsInHand': 7,
      'handValues': [FourOfAKind, FullHouse, ThreeOfAKind, ThreePair, TwoPair, OnePair, HighCard],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 5,
      'lowestQualified': null
    },
    'paigowpokersf6': {
      'cardsInHand': 7,
      'handValues': [StraightFlush, Flush, Straight],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 6,
      'lowestQualified': null
    },
    'paigowpokersf7': {
      'cardsInHand': 7,
      'handValues': [StraightFlush, Flush, Straight],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 7,
      'lowestQualified': null
    },
    'paigowpokerhi': {
      'cardsInHand': 5,
      'handValues': [FiveOfAKind, StraightFlush, FourOfAKind, FullHouse, Flush, Straight, ThreeOfAKind, TwoPair, OnePair, HighCard],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 5,
      'lowestQualified': null
    },
    'paigowpokerlo': {
      'cardsInHand': 2,
      'handValues': [OnePair, HighCard],
      'wildValue': 'O',
      'wildStatus': 0,
      'wheelStatus': 1,
      'sfQualify': 5,
      'lowestQualified': null
    }
  };

/**
 * Base Game class that defines the rules of the game.
 */
class Game {
    constructor(descr) {
        this.descr = descr
        this.cardsInHand = 0
        this.handValues = []
        this.wildValue = null
        this.wildStatus = 0
        this.wheelStatus = 0
        this.sfQualify = 5
        this.lowestQualified = null
        this.noKickers = null

        // Set values based on the game rules.
        if (!this.descr || !gameRules[this.descr]) {
            this.descr = 'standard'
        }
        this.cardsInHand = gameRules[this.descr]['cardsInHand']
        this.handValues = gameRules[this.descr]['handValues']
        this.wildValue = gameRules[this.descr]['wildValue']
        this.wildStatus = gameRules[this.descr]['wildStatus']
        this.wheelStatus = gameRules[this.descr]['wheelStatus']
        this.sfQualify = gameRules[this.descr]['sfQualify']
        this.lowestQualified = gameRules[this.descr]['lowestQualified']
        this.noKickers = gameRules[this.descr]['noKickers']
    }
}

export const _Card = Card
export const _Hand = Hand
export const _Game = Game
export const _RoyalFlush = RoyalFlush
export const _NaturalRoyalFlush = NaturalRoyalFlush
export const _WildRoyalFlush = WildRoyalFlush
export const _FiveOfAKind = FiveOfAKind
export const _StraightFlush = StraightFlush
export const _FourOfAKindPairPlus = FourOfAKindPairPlus
export const _FourOfAKind = FourOfAKind
export const _FourWilds = FourWilds
export const _TwoThreeOfAKind = TwoThreeOfAKind
export const _ThreeOfAKindTwoPair = ThreeOfAKindTwoPair
export const _FullHouse = FullHouse
export const _Flush = Flush
export const _Straight = Straight
export const _ThreeOfAKind = ThreeOfAKind
export const _ThreePair = ThreePair
export const _TwoPair = TwoPair
export const _OnePair = OnePair
export const _HighCard = HighCard
export const _PaiGowPokerHelper = PaiGowPokerHelper
